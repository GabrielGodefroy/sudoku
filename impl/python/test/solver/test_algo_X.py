from sudoku.solver.algo_X import (
    invert_coverage,
    build_list_of_constraints,
    build_map_of_constraint_per_cell,
    solve,
)
import pytest
import numpy as np
from sudoku.validity import check_solution, grid_match_clues


def test_size_of_constraint():
    # https://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html#Sudoku
    # https://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/presentationboard.pdf (slide 13 for size 9)
    assert len(build_list_of_constraints(1)) == 1 * 2 * 2
    assert len(build_map_of_constraint_per_cell(1)) == 1**3
    assert len(build_list_of_constraints(2)) == 4 * 4 * 4
    assert len(build_map_of_constraint_per_cell(2)) == 4**3
    # X are columns
    assert len(build_list_of_constraints(3)) == 4 * 9 * 9 == 324
    # Y are rows
    assert len(build_map_of_constraint_per_cell(3)) == 9**3 == 729


def test_build_list_of_constraints_size_1():
    constraints = build_list_of_constraints(1)
    assert constraints == [
        ("rc", (0, 0)),
        ("rn", (0, 1)),
        ("cn", (0, 1)),
        ("bn", (0, 1)),
    ]


def test_build_constraint_per_cell_size_1():
    constraints = build_map_of_constraint_per_cell(1)
    assert constraints == {
        (0, 0, 1): [("rc", (0, 0)), ("rn", (0, 1)), ("cn", (0, 1)), ("bn", (0, 1))]
    }


def test_build_list_of_constraints_size_2():
    assert build_list_of_constraints(2) == [
        # Position constraints for the 16 cells
        ("rc", (0, 0)),
        ("rc", (0, 1)),
        ("rc", (0, 2)),
        ("rc", (0, 3)),
        ("rc", (1, 0)),
        ("rc", (1, 1)),
        ("rc", (1, 2)),
        ("rc", (1, 3)),
        ("rc", (2, 0)),
        ("rc", (2, 1)),
        ("rc", (2, 2)),
        ("rc", (2, 3)),
        ("rc", (3, 0)),
        ("rc", (3, 1)),
        ("rc", (3, 2)),
        ("rc", (3, 3)),
        # row constraints for the 16 cells
        ("rn", (0, 1)),
        ("rn", (0, 2)),
        ("rn", (0, 3)),
        ("rn", (0, 4)),
        ("rn", (1, 1)),
        ("rn", (1, 2)),
        ("rn", (1, 3)),
        ("rn", (1, 4)),
        ("rn", (2, 1)),
        ("rn", (2, 2)),
        ("rn", (2, 3)),
        ("rn", (2, 4)),
        ("rn", (3, 1)),
        ("rn", (3, 2)),
        ("rn", (3, 3)),
        ("rn", (3, 4)),
        # columns constraints for 16 cells
        ("cn", (0, 1)),
        ("cn", (0, 2)),
        ("cn", (0, 3)),
        ("cn", (0, 4)),
        ("cn", (1, 1)),
        ("cn", (1, 2)),
        ("cn", (1, 3)),
        ("cn", (1, 4)),
        ("cn", (2, 1)),
        ("cn", (2, 2)),
        ("cn", (2, 3)),
        ("cn", (2, 4)),
        ("cn", (3, 1)),
        ("cn", (3, 2)),
        ("cn", (3, 3)),
        ("cn", (3, 4)),
        # block constraints for the 16 cells
        ("bn", (0, 1)),
        ("bn", (0, 2)),
        ("bn", (0, 3)),
        ("bn", (0, 4)),
        ("bn", (1, 1)),
        ("bn", (1, 2)),
        ("bn", (1, 3)),
        ("bn", (1, 4)),
        ("bn", (2, 1)),
        ("bn", (2, 2)),
        ("bn", (2, 3)),
        ("bn", (2, 4)),
        ("bn", (3, 1)),
        ("bn", (3, 2)),
        ("bn", (3, 3)),
        ("bn", (3, 4)),
    ]


def test_build_constraint_per_cell_size_2():
    assert build_map_of_constraint_per_cell(2) == {
        # list of constraints for the upper left elements (coord 0,0) for with value 1
        (0, 0, 1): [("rc", (0, 0)), ("rn", (0, 1)), ("cn", (0, 1)), ("bn", (0, 1))],
        # list of constraints for the upper left elements (coord 0,0) for with value 2
        (0, 0, 2): [("rc", (0, 0)), ("rn", (0, 2)), ("cn", (0, 2)), ("bn", (0, 2))],
        (0, 0, 3): [("rc", (0, 0)), ("rn", (0, 3)), ("cn", (0, 3)), ("bn", (0, 3))],
        (0, 0, 4): [("rc", (0, 0)), ("rn", (0, 4)), ("cn", (0, 4)), ("bn", (0, 4))],
        # list of constraints for second element (coord 0,1) for with value 1
        (0, 1, 1): [("rc", (0, 1)), ("rn", (0, 1)), ("cn", (1, 1)), ("bn", (0, 1))],
        (0, 1, 2): [("rc", (0, 1)), ("rn", (0, 2)), ("cn", (1, 2)), ("bn", (0, 2))],
        (0, 1, 3): [("rc", (0, 1)), ("rn", (0, 3)), ("cn", (1, 3)), ("bn", (0, 3))],
        (0, 1, 4): [("rc", (0, 1)), ("rn", (0, 4)), ("cn", (1, 4)), ("bn", (0, 4))],
        (0, 2, 1): [("rc", (0, 2)), ("rn", (0, 1)), ("cn", (2, 1)), ("bn", (1, 1))],
        (0, 2, 2): [("rc", (0, 2)), ("rn", (0, 2)), ("cn", (2, 2)), ("bn", (1, 2))],
        (0, 2, 3): [("rc", (0, 2)), ("rn", (0, 3)), ("cn", (2, 3)), ("bn", (1, 3))],
        (0, 2, 4): [("rc", (0, 2)), ("rn", (0, 4)), ("cn", (2, 4)), ("bn", (1, 4))],
        (0, 3, 1): [("rc", (0, 3)), ("rn", (0, 1)), ("cn", (3, 1)), ("bn", (1, 1))],
        (0, 3, 2): [("rc", (0, 3)), ("rn", (0, 2)), ("cn", (3, 2)), ("bn", (1, 2))],
        (0, 3, 3): [("rc", (0, 3)), ("rn", (0, 3)), ("cn", (3, 3)), ("bn", (1, 3))],
        (0, 3, 4): [("rc", (0, 3)), ("rn", (0, 4)), ("cn", (3, 4)), ("bn", (1, 4))],
        (1, 0, 1): [("rc", (1, 0)), ("rn", (1, 1)), ("cn", (0, 1)), ("bn", (0, 1))],
        (1, 0, 2): [("rc", (1, 0)), ("rn", (1, 2)), ("cn", (0, 2)), ("bn", (0, 2))],
        (1, 0, 3): [("rc", (1, 0)), ("rn", (1, 3)), ("cn", (0, 3)), ("bn", (0, 3))],
        (1, 0, 4): [("rc", (1, 0)), ("rn", (1, 4)), ("cn", (0, 4)), ("bn", (0, 4))],
        (1, 1, 1): [("rc", (1, 1)), ("rn", (1, 1)), ("cn", (1, 1)), ("bn", (0, 1))],
        (1, 1, 2): [("rc", (1, 1)), ("rn", (1, 2)), ("cn", (1, 2)), ("bn", (0, 2))],
        (1, 1, 3): [("rc", (1, 1)), ("rn", (1, 3)), ("cn", (1, 3)), ("bn", (0, 3))],
        (1, 1, 4): [("rc", (1, 1)), ("rn", (1, 4)), ("cn", (1, 4)), ("bn", (0, 4))],
        (1, 2, 1): [("rc", (1, 2)), ("rn", (1, 1)), ("cn", (2, 1)), ("bn", (1, 1))],
        (1, 2, 2): [("rc", (1, 2)), ("rn", (1, 2)), ("cn", (2, 2)), ("bn", (1, 2))],
        (1, 2, 3): [("rc", (1, 2)), ("rn", (1, 3)), ("cn", (2, 3)), ("bn", (1, 3))],
        (1, 2, 4): [("rc", (1, 2)), ("rn", (1, 4)), ("cn", (2, 4)), ("bn", (1, 4))],
        (1, 3, 1): [("rc", (1, 3)), ("rn", (1, 1)), ("cn", (3, 1)), ("bn", (1, 1))],
        (1, 3, 2): [("rc", (1, 3)), ("rn", (1, 2)), ("cn", (3, 2)), ("bn", (1, 2))],
        (1, 3, 3): [("rc", (1, 3)), ("rn", (1, 3)), ("cn", (3, 3)), ("bn", (1, 3))],
        (1, 3, 4): [("rc", (1, 3)), ("rn", (1, 4)), ("cn", (3, 4)), ("bn", (1, 4))],
        (2, 0, 1): [("rc", (2, 0)), ("rn", (2, 1)), ("cn", (0, 1)), ("bn", (2, 1))],
        (2, 0, 2): [("rc", (2, 0)), ("rn", (2, 2)), ("cn", (0, 2)), ("bn", (2, 2))],
        (2, 0, 3): [("rc", (2, 0)), ("rn", (2, 3)), ("cn", (0, 3)), ("bn", (2, 3))],
        (2, 0, 4): [("rc", (2, 0)), ("rn", (2, 4)), ("cn", (0, 4)), ("bn", (2, 4))],
        (2, 1, 1): [("rc", (2, 1)), ("rn", (2, 1)), ("cn", (1, 1)), ("bn", (2, 1))],
        (2, 1, 2): [("rc", (2, 1)), ("rn", (2, 2)), ("cn", (1, 2)), ("bn", (2, 2))],
        (2, 1, 3): [("rc", (2, 1)), ("rn", (2, 3)), ("cn", (1, 3)), ("bn", (2, 3))],
        (2, 1, 4): [("rc", (2, 1)), ("rn", (2, 4)), ("cn", (1, 4)), ("bn", (2, 4))],
        (2, 2, 1): [("rc", (2, 2)), ("rn", (2, 1)), ("cn", (2, 1)), ("bn", (3, 1))],
        (2, 2, 2): [("rc", (2, 2)), ("rn", (2, 2)), ("cn", (2, 2)), ("bn", (3, 2))],
        (2, 2, 3): [("rc", (2, 2)), ("rn", (2, 3)), ("cn", (2, 3)), ("bn", (3, 3))],
        (2, 2, 4): [("rc", (2, 2)), ("rn", (2, 4)), ("cn", (2, 4)), ("bn", (3, 4))],
        (2, 3, 1): [("rc", (2, 3)), ("rn", (2, 1)), ("cn", (3, 1)), ("bn", (3, 1))],
        (2, 3, 2): [("rc", (2, 3)), ("rn", (2, 2)), ("cn", (3, 2)), ("bn", (3, 2))],
        (2, 3, 3): [("rc", (2, 3)), ("rn", (2, 3)), ("cn", (3, 3)), ("bn", (3, 3))],
        (2, 3, 4): [("rc", (2, 3)), ("rn", (2, 4)), ("cn", (3, 4)), ("bn", (3, 4))],
        (3, 0, 1): [("rc", (3, 0)), ("rn", (3, 1)), ("cn", (0, 1)), ("bn", (2, 1))],
        (3, 0, 2): [("rc", (3, 0)), ("rn", (3, 2)), ("cn", (0, 2)), ("bn", (2, 2))],
        (3, 0, 3): [("rc", (3, 0)), ("rn", (3, 3)), ("cn", (0, 3)), ("bn", (2, 3))],
        (3, 0, 4): [("rc", (3, 0)), ("rn", (3, 4)), ("cn", (0, 4)), ("bn", (2, 4))],
        (3, 1, 1): [("rc", (3, 1)), ("rn", (3, 1)), ("cn", (1, 1)), ("bn", (2, 1))],
        (3, 1, 2): [("rc", (3, 1)), ("rn", (3, 2)), ("cn", (1, 2)), ("bn", (2, 2))],
        (3, 1, 3): [("rc", (3, 1)), ("rn", (3, 3)), ("cn", (1, 3)), ("bn", (2, 3))],
        (3, 1, 4): [("rc", (3, 1)), ("rn", (3, 4)), ("cn", (1, 4)), ("bn", (2, 4))],
        (3, 2, 1): [("rc", (3, 2)), ("rn", (3, 1)), ("cn", (2, 1)), ("bn", (3, 1))],
        (3, 2, 2): [("rc", (3, 2)), ("rn", (3, 2)), ("cn", (2, 2)), ("bn", (3, 2))],
        (3, 2, 3): [("rc", (3, 2)), ("rn", (3, 3)), ("cn", (2, 3)), ("bn", (3, 3))],
        (3, 2, 4): [("rc", (3, 2)), ("rn", (3, 4)), ("cn", (2, 4)), ("bn", (3, 4))],
        (3, 3, 1): [("rc", (3, 3)), ("rn", (3, 1)), ("cn", (3, 1)), ("bn", (3, 1))],
        (3, 3, 2): [("rc", (3, 3)), ("rn", (3, 2)), ("cn", (3, 2)), ("bn", (3, 2))],
        (3, 3, 3): [("rc", (3, 3)), ("rn", (3, 3)), ("cn", (3, 3)), ("bn", (3, 3))],
        (3, 3, 4): [("rc", (3, 3)), ("rn", (3, 4)), ("cn", (3, 4)), ("bn", (3, 4))],
    }


def test_invert_coverage_for_size_2():

    list_of_constraints = build_list_of_constraints(2)
    constraint_map_per_cell = build_map_of_constraint_per_cell(2)
    inverted_coverage = invert_coverage(list_of_constraints, constraint_map_per_cell)

    assert inverted_coverage == {
        # Position constraints for the 16 cells
        # cell (0,0) can have value 1, 2, 3 or 4
        ("rc", (0, 0)): {(0, 0, 4), (0, 0, 1), (0, 0, 2), (0, 0, 3)},
        ("rc", (0, 1)): {(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 1, 1)},
        ("rc", (0, 2)): {(0, 2, 1), (0, 2, 2), (0, 2, 3), (0, 2, 4)},
        ("rc", (0, 3)): {(0, 3, 4), (0, 3, 1), (0, 3, 2), (0, 3, 3)},
        ("rc", (1, 0)): {(1, 0, 1), (1, 0, 2), (1, 0, 3), (1, 0, 4)},
        ("rc", (1, 1)): {(1, 1, 3), (1, 1, 4), (1, 1, 1), (1, 1, 2)},
        ("rc", (1, 2)): {(1, 2, 1), (1, 2, 2), (1, 2, 3), (1, 2, 4)},
        ("rc", (1, 3)): {(1, 3, 1), (1, 3, 2), (1, 3, 3), (1, 3, 4)},
        ("rc", (2, 0)): {(2, 0, 1), (2, 0, 2), (2, 0, 3), (2, 0, 4)},
        ("rc", (2, 1)): {(2, 1, 1), (2, 1, 2), (2, 1, 3), (2, 1, 4)},
        ("rc", (2, 2)): {(2, 2, 3), (2, 2, 4), (2, 2, 1), (2, 2, 2)},
        ("rc", (2, 3)): {(2, 3, 1), (2, 3, 2), (2, 3, 3), (2, 3, 4)},
        ("rc", (3, 0)): {(3, 0, 1), (3, 0, 2), (3, 0, 3), (3, 0, 4)},
        ("rc", (3, 1)): {(3, 1, 3), (3, 1, 4), (3, 1, 1), (3, 1, 2)},
        ("rc", (3, 2)): {(3, 2, 1), (3, 2, 2), (3, 2, 3), (3, 2, 4)},
        ("rc", (3, 3)): {(3, 3, 1), (3, 3, 2), (3, 3, 3), (3, 3, 4)},
        # row constraint
        # element in row 0 with value 1 can be in column 2, 0, 3 or 1
        ("rn", (0, 1)): {(0, 2, 1), (0, 0, 1), (0, 3, 1), (0, 1, 1)},
        ("rn", (0, 2)): {(0, 1, 2), (0, 2, 2), (0, 3, 2), (0, 0, 2)},
        ("rn", (0, 3)): {(0, 1, 3), (0, 2, 3), (0, 3, 3), (0, 0, 3)},
        ("rn", (0, 4)): {(0, 0, 4), (0, 1, 4), (0, 3, 4), (0, 2, 4)},
        ("rn", (1, 1)): {(1, 2, 1), (1, 0, 1), (1, 1, 1), (1, 3, 1)},
        ("rn", (1, 2)): {(1, 3, 2), (1, 2, 2), (1, 0, 2), (1, 1, 2)},
        ("rn", (1, 3)): {(1, 1, 3), (1, 2, 3), (1, 0, 3), (1, 3, 3)},
        ("rn", (1, 4)): {(1, 3, 4), (1, 1, 4), (1, 2, 4), (1, 0, 4)},
        ("rn", (2, 1)): {(2, 0, 1), (2, 1, 1), (2, 3, 1), (2, 2, 1)},
        ("rn", (2, 2)): {(2, 3, 2), (2, 0, 2), (2, 1, 2), (2, 2, 2)},
        ("rn", (2, 3)): {(2, 2, 3), (2, 3, 3), (2, 0, 3), (2, 1, 3)},
        ("rn", (2, 4)): {(2, 2, 4), (2, 0, 4), (2, 3, 4), (2, 1, 4)},
        ("rn", (3, 1)): {(3, 2, 1), (3, 0, 1), (3, 1, 1), (3, 3, 1)},
        ("rn", (3, 2)): {(3, 3, 2), (3, 2, 2), (3, 0, 2), (3, 1, 2)},
        ("rn", (3, 3)): {(3, 1, 3), (3, 3, 3), (3, 2, 3), (3, 0, 3)},
        ("rn", (3, 4)): {(3, 3, 4), (3, 1, 4), (3, 2, 4), (3, 0, 4)},
        # column constraint
        # element in colum 0 with value 1 can be in row 2, 3, 1 or 0
        ("cn", (0, 1)): {(2, 0, 1), (3, 0, 1), (1, 0, 1), (0, 0, 1)},
        ("cn", (0, 2)): {(2, 0, 2), (1, 0, 2), (0, 0, 2), (3, 0, 2)},
        ("cn", (0, 3)): {(2, 0, 3), (1, 0, 3), (3, 0, 3), (0, 0, 3)},
        ("cn", (0, 4)): {(0, 0, 4), (3, 0, 4), (2, 0, 4), (1, 0, 4)},
        ("cn", (1, 1)): {(2, 1, 1), (3, 1, 1), (1, 1, 1), (0, 1, 1)},
        ("cn", (1, 2)): {(0, 1, 2), (2, 1, 2), (3, 1, 2), (1, 1, 2)},
        ("cn", (1, 3)): {(1, 1, 3), (0, 1, 3), (2, 1, 3), (3, 1, 3)},
        ("cn", (1, 4)): {(3, 1, 4), (1, 1, 4), (0, 1, 4), (2, 1, 4)},
        ("cn", (2, 1)): {(1, 2, 1), (0, 2, 1), (2, 2, 1), (3, 2, 1)},
        ("cn", (2, 2)): {(2, 2, 2), (0, 2, 2), (3, 2, 2), (1, 2, 2)},
        ("cn", (2, 3)): {(2, 2, 3), (1, 2, 3), (0, 2, 3), (3, 2, 3)},
        ("cn", (2, 4)): {(2, 2, 4), (0, 2, 4), (3, 2, 4), (1, 2, 4)},
        ("cn", (3, 1)): {(2, 3, 1), (3, 3, 1), (1, 3, 1), (0, 3, 1)},
        ("cn", (3, 2)): {(3, 3, 2), (2, 3, 2), (1, 3, 2), (0, 3, 2)},
        ("cn", (3, 3)): {(3, 3, 3), (2, 3, 3), (1, 3, 3), (0, 3, 3)},
        ("cn", (3, 4)): {(0, 3, 4), (3, 3, 4), (2, 3, 4), (1, 3, 4)},
        # column constraint
        # element in block 0 with value 1 can be located at (0,0), (0,1), (1,0) or (1,1)
        ("bn", (0, 1)): {(1, 0, 1), (0, 0, 1), (1, 1, 1), (0, 1, 1)},
        ("bn", (0, 2)): {(0, 1, 2), (1, 0, 2), (0, 0, 2), (1, 1, 2)},
        ("bn", (0, 3)): {(1, 1, 3), (0, 1, 3), (1, 0, 3), (0, 0, 3)},
        ("bn", (0, 4)): {(0, 0, 4), (1, 1, 4), (0, 1, 4), (1, 0, 4)},
        ("bn", (1, 1)): {(1, 2, 1), (0, 2, 1), (1, 3, 1), (0, 3, 1)},
        ("bn", (1, 2)): {(0, 2, 2), (1, 3, 2), (0, 3, 2), (1, 2, 2)},
        ("bn", (1, 3)): {(1, 2, 3), (0, 2, 3), (1, 3, 3), (0, 3, 3)},
        ("bn", (1, 4)): {(0, 3, 4), (0, 2, 4), (1, 3, 4), (1, 2, 4)},
        ("bn", (2, 1)): {(2, 0, 1), (2, 1, 1), (3, 0, 1), (3, 1, 1)},
        ("bn", (2, 2)): {(3, 1, 2), (2, 0, 2), (2, 1, 2), (3, 0, 2)},
        ("bn", (2, 3)): {(3, 1, 3), (2, 0, 3), (2, 1, 3), (3, 0, 3)},
        ("bn", (2, 4)): {(3, 1, 4), (3, 0, 4), (2, 0, 4), (2, 1, 4)},
        ("bn", (3, 1)): {(2, 3, 1), (3, 2, 1), (3, 3, 1), (2, 2, 1)},
        ("bn", (3, 2)): {(2, 3, 2), (3, 3, 2), (3, 2, 2), (2, 2, 2)},
        ("bn", (3, 3)): {(2, 2, 3), (2, 3, 3), (3, 3, 3), (3, 2, 3)},
        ("bn", (3, 4)): {(3, 3, 4), (2, 2, 4), (2, 3, 4), (3, 2, 4)},
    }


def test_solve_X_on_empty_9x9_grid():
    clues = np.ndarray(shape=(9, 9), dtype=int)
    clues.fill(0)
    solution = solve(clues)
    assert check_solution(solution)
    assert grid_match_clues(solution, clues)


def test_solve_X_on_empty_4x4_grid():
    clues = np.ndarray(shape=(4, 4), dtype=int)
    clues.fill(0)
    solution = solve(clues)
    assert solution is not None
    # TODO assert check_solution(solution)
    # TODO assert grid_match_clues(solution, clues)


def test_solve_X_on_impossible_4x4_grid():
    clues = np.ndarray(shape=(4, 4), dtype=int)
    clues.fill(0)
    clues[0, 0] = 1
    clues[0, 1] = 1
    with pytest.raises(KeyError):  # TODO wrap with other exception
        solve(clues)


def test_solve_X_on_impossible_9x9_grid():
    clues = np.ndarray(shape=(9, 9), dtype=int)
    clues.fill(0)
    clues[0, 0] = 1
    clues[0, 1] = 1
    with pytest.raises(KeyError):  # TODO wrap with other exception
        solve(clues)


@pytest.mark.slow
def test_solve_on_easy_grid():
    clues = np.array(
        [
            [5, 3, 0, 0, 7, 0, 0, 0, 0],
            [6, 0, 0, 1, 9, 5, 0, 0, 0],
            [0, 9, 8, 0, 0, 0, 0, 6, 0],
            [8, 0, 0, 0, 6, 0, 0, 0, 3],
            [4, 0, 0, 8, 0, 3, 0, 0, 1],
            [7, 0, 0, 0, 2, 0, 0, 0, 6],
            [0, 6, 0, 0, 0, 0, 2, 8, 0],
            [0, 0, 0, 4, 1, 9, 0, 0, 5],
            [0, 0, 0, 0, 8, 0, 0, 0, 0],
        ]
    )
    solution = solve(clues)
    assert check_solution(solution)
    assert grid_match_clues(solution, clues)
